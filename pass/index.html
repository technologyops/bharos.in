<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PASS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .tabs {
            display: flex;
            background: #f8f9fa;
        }

        .tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            color: #6c757d;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }

        .tab.active {
            color: #495057;
            border-bottom-color: #667eea;
            background: white;
        }

        .tab-content {
            padding: 25px;
            min-height: 400px;
        }

        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #495057;
        }

        .input-options {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .input-option {
            flex: 1;
            padding: 8px 12px;
            background: #e9ecef;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s ease;
        }

        .input-option.active {
            background: #667eea;
            color: white;
        }

        textarea, input[type="file"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
            font-family: inherit;
        }

        textarea {
            resize: vertical;
            min-height: 120px;
        }

        textarea:focus, input:focus {
            outline: none;
            border-color: #667eea;
        }

        .result {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #28a745;
            display: none;
        }

        .result.error {
            border-left-color: #dc3545;
            background: #f8d7da;
        }

        .result pre {
            font-size: 0.85rem;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            color: #856404;
        }

        @media (max-width: 480px) {
            .container {
                margin: 10px;
                border-radius: 15px;
            }

            body {
                padding: 10px;
            }

            .tab-content {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>PASS (Personal Authentic Software Services)</h1>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('verify')">üîç Verify</button>
            <button class="tab" onclick="switchTab('sign')">‚úçÔ∏è Sign</button>
        </div>

        <div class="tab-content">
            <div id="verify" class="tab-panel active">
                <div class="input-group">
                    <input type="file" id="verifyFile" onchange="onVerify(this)" accept=".pass, *" style="display: none;">
                    <label for="verifyFile">Select file to Verify</label>
                </div>
                <div id="verifyResult" class="result"></div>
            </div>

            <div id="sign" class="tab-panel">
                <!--div class="input-group" id="signFileGroup" style="display: none;"-->
                <div class="input-group" id="signFileGroup">
                    <input type="file" id="signFile" onchange="onSign(this)" style="display: none;">
                    <label for="signFile">Select file to Sign</label>
                </div>
                <label for="secretKey">secret Key (keep secret :)</label>
                <textarea id="secretKey" placeholder="Enter secretKey..." onkeyup="onSecretKey(this)">RUVGBFFZBYOZ6QACCLIUYUMMQ2FORMQ3U4PGR7E6NRDUOWOEDKHA</textarea>
                <div id="signResult" class="result"></div>
            </div>
        </div>
    </div>

<script>
</script>
    <script type="module">
const St={p:0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffedn,n:0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3edn,h:8n,a:0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffecn,d:0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3n,Gx:0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an,Gy:0x6666666666666666666666666666666666666666666666666666666666666658n},{p:h,n:Y,Gx:ot,Gy:ct,a:P,d:q}=St,Rt=8n,A=32,z=64,b=(t="")=>{throw new Error(t)},zt=t=>typeof t=="bigint",rt=t=>typeof t=="string",Ut=t=>t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array",_=(t,n)=>!Ut(t)||typeof n=="number"&&n>0&&t.length!==n?b("Uint8Array expected"):t,U=t=>new Uint8Array(t),K=t=>Uint8Array.from(t),ft=(t,n)=>t.toString(16).padStart(n,"0"),N=t=>Array.from(_(t)).map(n=>ft(n,2)).join(""),m={_0:48,_9:57,A:65,F:70,a:97,f:102},it=t=>{if(t>=m._0&&t<=m._9)return t-m._0;if(t>=m.A&&t<=m.F)return t-(m.A-10);if(t>=m.a&&t<=m.f)return t-(m.a-10)},V=t=>{const n="hex invalid";if(!rt(t))return b(n);const e=t.length,s=e/2;if(e%2)return b(n);const o=U(s);for(let c=0,f=0;c<s;c++,f+=2){const a=it(t.charCodeAt(f)),i=it(t.charCodeAt(f+1));if(a===void 0||i===void 0)return b(n);o[c]=a*16+i}return o},E=(t,n)=>_(rt(t)?V(t):K(_(t)),n),at=()=>globalThis?.crypto,lt=()=>at()?.subtle??b("crypto.subtle must be defined"),S=(...t)=>{const n=U(t.reduce((s,o)=>s+_(o).length,0));let e=0;return t.forEach(s=>{n.set(s,e),e+=s.length}),n},ut=(t=A)=>at().getRandomValues(U(t)),O=BigInt,v=(t,n,e,s="bad number: out of range")=>zt(t)&&n<=t&&t<e?t:b(s),r=(t,n=h)=>{const e=t%n;return e>=0n?e:n+e},dt=t=>r(t,Y),yt=(t,n)=>{(t===0n||n<=0n)&&b("no inverse n="+t+" mod="+n);let e=r(t,n),s=n,o=0n,c=1n,f=1n,a=0n;for(;e!==0n;){const i=s/e,l=s%e,u=o-f*i,d=c-a*i;s=e,e=l,o=f,c=a,f=u,a=d}return s===1n?r(o,n):b("no inverse")},Xt=t=>{const n=X[t];return typeof n!="function"&&b("hashes."+t+" not set"),n},ht=t=>t instanceof x?t:b("Point expected"),D=2n**256n;class x{static BASE;static ZERO;ex;ey;ez;et;constructor(n,e,s,o){const c=D;this.ex=v(n,0n,c),this.ey=v(e,0n,c),this.ez=v(s,1n,c),this.et=v(o,0n,c),Object.freeze(this)}static fromAffine(n){return new x(n.x,n.y,1n,r(n.x*n.y))}static fromBytes(n,e=!1){const s=q,o=K(_(n,A)),c=n[31];o[31]=c&-129;const f=M(o);v(f,0n,e?D:h);const i=r(f*f),l=r(i-1n),u=r(s*i+1n);let{isValid:d,value:y}=Yt(l,u);d||b("bad point: y not sqrt");const p=(y&1n)===1n,w=(c&128)!==0;return!e&&y===0n&&w&&b("bad point: x==0, isLastByteOdd"),w!==p&&(y=r(-y)),new x(y,f,1n,r(y*f))}assertValidity(){const n=P,e=q,s=this;if(s.is0())throw new Error("bad point: ZERO");const{ex:o,ey:c,ez:f,et:a}=s,i=r(o*o),l=r(c*c),u=r(f*f),d=r(u*u),y=r(i*n),p=r(u*r(y+l)),w=r(d+r(e*r(i*l)));if(p!==w)throw new Error("bad point: equation left != right (1)");const T=r(o*c),Z=r(f*a);if(T!==Z)throw new Error("bad point: equation left != right (2)");return this}equals(n){const{ex:e,ey:s,ez:o}=this,{ex:c,ey:f,ez:a}=ht(n),i=r(e*a),l=r(c*o),u=r(s*a),d=r(f*o);return i===l&&u===d}is0(){return this.equals(R)}negate(){return new x(r(-this.ex),this.ey,this.ez,r(-this.et))}double(){const{ex:n,ey:e,ez:s}=this,o=P,c=r(n*n),f=r(e*e),a=r(2n*r(s*s)),i=r(o*c),l=n+e,u=r(r(l*l)-c-f),d=i+f,y=d-a,p=i-f,w=r(u*y),T=r(d*p),Z=r(u*p),H=r(y*d);return new x(w,T,H,Z)}add(n){const{ex:e,ey:s,ez:o,et:c}=this,{ex:f,ey:a,ez:i,et:l}=ht(n),u=P,d=q,y=r(e*f),p=r(s*a),w=r(c*d*l),T=r(o*i),Z=r((e+s)*(f+a)-y-p),H=r(T-w),et=r(T+w),st=r(p-u*y),_t=r(Z*H),vt=r(et*st),Tt=r(Z*st),Zt=r(H*et);return new x(_t,vt,Zt,Tt)}multiply(n,e=!0){if(!e&&(n===0n||this.is0()))return R;if(v(n,1n,Y),n===1n)return this;if(this.equals(g))return qt(n).p;let s=R,o=g;for(let c=this;n>0n;c=c.double(),n>>=1n)n&1n?s=s.add(c):e&&(o=o.add(c));return s}toAffine(){const{ex:n,ey:e,ez:s}=this;if(this.equals(R))return{x:0n,y:1n};const o=yt(s,h);return r(s*o)!==1n&&b("invalid inverse"),{x:r(n*o),y:r(e*o)}}toBytes(){const{x:n,y:e}=this.assertValidity().toAffine(),s=bt(e);return s[31]|=n&1n?128:0,s}toHex(){return N(this.toBytes())}clearCofactor(){return this.multiply(O(Rt),!1)}isSmallOrder(){return this.clearCofactor().is0()}isTorsionFree(){let n=this.multiply(Y/2n,!1).double();return Y%2n&&(n=n.add(this)),n.is0()}static fromHex(n,e){return x.fromBytes(E(n),e)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}toRawBytes(){return this.toBytes()}}const g=new x(ot,ct,1n,r(ot*ct)),R=new x(0n,1n,1n,0n);x.BASE=g,x.ZERO=R;const bt=t=>V(ft(v(t,0n,D),z)).reverse(),M=t=>O("0x"+N(K(_(t)).reverse())),B=(t,n)=>{let e=t;for(;n-- >0n;)e*=e,e%=h;return e},Ht=t=>{const e=t*t%h*t%h,s=B(e,2n)*e%h,o=B(s,1n)*t%h,c=B(o,5n)*o%h,f=B(c,10n)*c%h,a=B(f,20n)*f%h,i=B(a,40n)*a%h,l=B(i,80n)*i%h,u=B(l,80n)*i%h,d=B(u,10n)*c%h;return{pow_p_5_8:B(d,2n)*t%h,b2:e}},xt=0x2b8324804fc1df0b2b4d00993dfbd7a72f431806ad2fe478c4ee1b274a0ea0b0n,Yt=(t,n)=>{const e=r(n*n*n),s=r(e*e*n),o=Ht(t*s).pow_p_5_8;let c=r(t*e*o);const f=r(n*c*c),a=c,i=r(c*xt),l=f===t,u=f===r(-t),d=f===r(-t*xt);return l&&(c=a),(u||d)&&(c=i),(r(c)&1n)===1n&&(c=r(-c)),{isValid:l||u,value:c}},C=t=>dt(M(t)),k=(...t)=>X.sha512Async(...t),I=(...t)=>Xt("sha512Sync")(...t),pt=t=>{const n=t.slice(0,A);n[0]&=248,n[31]&=127,n[31]|=64;const e=t.slice(A,z),s=C(n),o=g.multiply(s),c=o.toBytes();return{head:n,prefix:e,scalar:s,point:o,pointBytes:c}},W=t=>k(E(t,A)).then(pt),j=t=>pt(I(E(t,A))),Ot=t=>W(t).then(n=>n.pointBytes),Ct=t=>j(t).pointBytes,$=t=>k(t.hashable).then(t.finish),wt=t=>t.finish(I(t.hashable)),At=(t,n,e)=>{const{pointBytes:s,scalar:o}=t,c=C(n),f=g.multiply(c).toBytes();return{hashable:S(f,s,e),finish:l=>{const u=dt(c+C(l)*o);return _(S(f,bt(u)),z)}}},Ft=async(t,n)=>{const e=E(t),s=await W(n),o=await k(s.prefix,e);return $(At(s,o,e))},Dt=(t,n)=>{const e=E(t),s=j(n),o=I(s.prefix,e);return wt(At(s,o,e))},F={zip215:!0},J=(t,n,e,s=F)=>{t=E(t,z),n=E(n),e=E(e,A);const{zip215:o}=s;let c,f,a,i,l=Uint8Array.of();try{c=x.fromHex(e,o),f=x.fromHex(t.slice(0,A),o),a=M(t.slice(A,z)),i=g.multiply(a,!1),l=S(f.toBytes(),c.toBytes(),n)}catch{}return{hashable:l,finish:d=>{if(i==null||!o&&c.isSmallOrder())return!1;const y=C(d);return f.add(c.multiply(y,!1)).add(i.negate()).clearCofactor().is0()}}},Mt=async(t,n,e,s=F)=>$(J(t,n,e,s)),kt=(t,n,e,s=F)=>wt(J(t,n,e,s)),X={sha512Async:async(...t)=>{const n=lt(),e=S(...t);return U(await n.digest("SHA-512",e.buffer))},sha512Sync:void 0,bytesToHex:N,hexToBytes:V,concatBytes:S,mod:r,invert:yt,randomBytes:ut},Lt={getExtendedPublicKeyAsync:W,getExtendedPublicKey:j,randomPrivateKey:()=>ut(A),precompute:(t=8,n=g)=>(n.multiply(3n),n)},L=8,Gt=256,Bt=Math.ceil(Gt/L)+1,Q=2**(L-1),Pt=()=>{const t=[];let n=g,e=n;for(let s=0;s<Bt;s++){e=n,t.push(e);for(let o=1;o<Q;o++)e=e.add(n),t.push(e);n=e.double()}return t};let mt;const gt=(t,n)=>{const e=n.negate();return t?e:n},qt=t=>{const n=mt||(mt=Pt());let e=R,s=g;const o=2**L,c=o,f=O(o-1),a=O(L);for(let i=0;i<Bt;i++){let l=Number(t&f);t>>=a,l>Q&&(l-=c,t+=1n);const u=i*Q,d=u,y=u+Math.abs(l)-1,p=i%2!==0,w=l<0;l===0?s=s.add(gt(p,n[d])):e=e.add(gt(w,n[y]))}return t!==0n&&b("invalid wnaf"),{p:e,f:s}},tt="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";function nt(t){const n=new Uint8Array(t);let e="",s=0,o=0;for(let c=0;c<n.length;c++)for(o=o<<8|n[c],s+=8;s>=5;)e+=tt[o>>>s-5&31],s-=5;return s>0&&(e+=tt[o<<5-s&31]),e}function G(t){t=t.toUpperCase().replace(/=+$/,"");let n=0,e=0,s=[];for(let o=0;o<t.length;o++){const c=t[o],f=tt.indexOf(c);if(f===-1)throw new Error(`Invalid Base32 character: ${c}`);e=e<<5|f,n+=5,n>=8&&(s.push(e>>>n-8&255),n-=8)}return new Uint8Array(s)}X.sha512Sync=async(...t)=>U(await lt().digest("SHA-512",S(...t).buffer));function Et(t,n=24){const e=new TextDecoder("utf-8",{fatal:!0});try{const s=e.decode(t.slice(0,n));return!0}catch{}return!1}const Kt=async(t,n)=>{let e=Et(n);if(e){if(n.length<156)return!1}else if(n.length<97)return!1;let s,o,c;if(t.endsWith(".pass"))if(e){const f=new TextDecoder("utf-8");let a=G(f.decode(n.slice(0,156)));s=a.slice(1,33),o=a.slice(33,97),n=n.slice(156)}else s=n.slice(1,33),o=n.slice(33,97),n=n.slice(97);else{if(t.length<157)return!1;let f;try{f=G(t.slice(0,156))}catch{return!1}s=f.slice(1,33),o=f.slice(33,97)}return c=await X.sha512Async(n),$(J(o,c,s,F))},Nt=async(t,n,e=!1)=>{n.length==52&&(n=G(n));const s=await Ot(n),o=await X.sha512Async(t),c=await Ft(o,n);if(e)if(Et(t)){const f=new TextDecoder("utf-8");return nt(Uint8Array.from([0,...s,...c]))+f.decode(t)}else return Uint8Array.from([0,...s,...c,...t]);else return nt(Uint8Array.from([0,...s,...c]))},Vt=Lt.randomPrivateKey;
const pass = {
  genKey: Vt,
  getPublicKey: Vt,
  signfile: Nt,
  verifile: Kt,
  bytesToB32: nt,
  b32ToBytes: G
}
        var saveData = (function () {
            var a = document.createElement("a");
            document.body.appendChild(a);
            a.style = "display: none";
            return function (data, fileName) {
              let blob = new Blob([data], {type: 'application/octet-stream'}),
                  url = window.URL.createObjectURL(blob);
              a.href = url;
              a.download = fileName;
              a.click();
              window.URL.revokeObjectURL(url);
            };
        }());

        // Make functions global so they can be called from onclick handlers
        window.switchTab = switchTab;
        window.onVerify = onVerify;
        window.onSign = onSign;
        window.onSecretKey = onSecretKey;

       function onSecretKey(el) {
         document.getElementById('signFileGroup').style.display = (el.value.trim().length == 52) ? 'block' : 'none';
       }

       //document.getElementById('verifyFile').addEventListener("change", )
       async function onVerify(el) {
         let f = el.files[0];
         try {
            const isValid = await pass.verifile(f.name, new Uint8Array(await f.arrayBuffer()));
            if (isValid) {
              showResult('verifyResult', '‚úÖ PASS' + f.name);
              el.value = ''; // clear the selected file
              return;
            }
         } catch (error) {
            console.error("Error reading file:", error);
         }
         el.value = ''; // clear the selected file
         showResult('verifyResult', '‚ùå FAIL' + f.name, true);
       }

       //document.getElementById('signFile').addEventListener("change", async )
       async function onSign(el) {
         let secretKey = document.getElementById('secretKey').value.trim();
         if (secretKey.length == 52) {
           let f = el.files[0];
           try {
              const content = await f.arrayBuffer();
              const passContent = await pass.signfile(new Uint8Array(content), secretKey, true);
              saveData(passContent, f.name+'.pass');
              //showResult('signResult', fileName);
          } catch (error) {
              console.error("Error file:", error);
          }
        }
        el.value = ''; // clear the selected file
       }

        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));

            // Find the clicked tab
            const clickedTab = Array.from(document.querySelectorAll('.tab')).find(tab =>
                tab.textContent.toLowerCase() === tabName.toLowerCase()
            );
            if (clickedTab) {
                clickedTab.classList.add('active');
            }

            document.getElementById(tabName).classList.add('active');
        }

        function showResult(elementId, message, isError = false) {
            const resultEl = document.getElementById(elementId);
            resultEl.innerHTML = `<pre>${message}</pre>`;
            resultEl.className = isError ? 'result error' : 'result';
            resultEl.style.display = 'block';
        }
    </script>
</body>
</html>
